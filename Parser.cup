import java_cup.runtime.*;
import java.io.*;
import java.util.*;


parser code {:
	   Lexer lexer;

	   public SmplParser(Lexer l) {
	   		  super(l);
			  lexer = l;
	   }

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
							 " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
							   	 lexer.getText());
		}
:};

init with {:
	  :};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println("Line " + lexer.getLine() + ", pos " +
				       lexer.getChar() +
				       ": Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};



terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, LB_COLON, RB_COLON;
terminal IS_PAIR, PAIR, CAR, CDR, LIST, SIZE, EQV, EQL, SUBSTR, DEF, PROC;

// Arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal AND, OR, NOT;
terminal BIT_AND, BIT_OR, BIT_NOT;
terminal SEMI, AT;

// Comparators
terminal GT, LT, GE, LE, NE, ASSIGN, COMMA;

// Types
terminal String VAR;
terminal Integer INT;
terminal Double DOUBLE;
terminal Character CHAR;

terminal TRUE;
terminal FALSE;

non terminal ExpLit bool;

non terminal Exp expression, boolExp, term, factor;
non terminal Statement stmt;
non terminal StatementSequence stmtList;
non terminal StatementDefinition definition;
non terminal SmplProgram program;

non terminal ArrayList<Exp> expressionSequence;

program ::= stmtList:seq {: RESULT = new SmplProgram(seq); :};

stmtList ::= stmtList:seq stmt:s {: RESULT = seq.add(s); :} | 
			 stmt:s {: RESULT = new StatementSequence(s); :};
			 
stmt ::= expression:e SEMI {: RESULT = new Statement(e); :} |
	 	 definition:d {: RESULT = d; :};

definition ::= VAR:var ASSIGN expression:e SEMI {: RESULT = new StatementDefinition(var, e); :};

expression ::= expression:e PLUS  term:t {: RESULT = new ExpAdd(e, t); :} |
		   	   expression:e MINUS term:t {: RESULT = new ExpSub(e, t); :} |
			   boolExp:b {: RESULT = b; :};

expressionSequence ::= expressionSequence:seq COMMA expression:e  {: seq.add(e); RESULT = seq; :} |
				   	   expression:e {:
					   		ArrayList<Exp> result = new ArrayList<>();
							result.add(e);
							RESULT = result;
						:};

bool ::= TRUE {: RESULT = new ExpLit(true, "smpl-boolean"); :} |
	 	 FALSE {: RESULT = new ExpLit(false, "smpl-boolean"); :};

boolExp ::= boolExp:b AND term:t {: RESULT = new ExpAnd(b, t); :} |
			boolExp:b OR term:t {: RESULT = new ExpOr(b, t); :} |			
			term:t {: RESULT = t; :};

term ::= term:t MUL factor:f {: RESULT = new ExpMul(t, f); :} |
	 	 term:t DIV factor:f {: RESULT = new ExpDiv(t, f); :} |
		 term:t MOD factor:f {: RESULT = new ExpMod(t, f); :} |
		 factor:f {: RESULT = f; :};

factor ::= INT:v {: RESULT = new ExpLit(v, "smpl-integer"); :} |
	   	   DOUBLE:v {: RESULT = new ExpLit(v, "smpl-double"); :} |
		   bool:b {: RESULT = b; :} |		   
		   VAR:var {: RESULT = new ExpVar(var); :} |		   
		   LPAREN expression:e RPAREN {: RESULT = e; :} |
		   LPAREN MINUS expression:e RPAREN {: :};

empty ::= ;